/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  accessToken: "",
  refreshToken: "",
  tokenExpiry: 0,
  syncFolderId: "",
  syncFolderName: "ObsidianVault",
  autoSync: false,
  autoSyncInterval: 30,
  conflictResolution: "newer",
  syncOnStartup: false,
  syncOnSave: false,
  excludedFolders: [".obsidian", ".git", ".trash"],
  excludedExtensions: [],
  includeHiddenFiles: false,
  lastSyncTime: 0,
  debugMode: false
};

// src/googleAuth.ts
var import_obsidian = require("obsidian");
var SCOPES = [
  "https://www.googleapis.com/auth/drive.file",
  "https://www.googleapis.com/auth/drive.appdata"
];
var GOOGLE_AUTH_URL = "https://accounts.google.com/o/oauth2/v2/auth";
var GOOGLE_TOKEN_URL = "https://oauth2.googleapis.com/token";
var GoogleAuthService = class {
  constructor(plugin) {
    this.credentials = null;
    this.localServer = null;
    this.redirectUri = "http://localhost:42813/callback";
    this.plugin = plugin;
  }
  setCredentials(credentials) {
    this.credentials = credentials;
  }
  hasCredentials() {
    return this.credentials !== null && this.credentials.clientId !== "" && this.credentials.clientSecret !== "";
  }
  isAuthenticated() {
    return this.plugin.settings.accessToken !== "" && this.plugin.settings.refreshToken !== "" && Date.now() < this.plugin.settings.tokenExpiry;
  }
  async getValidAccessToken() {
    if (!this.plugin.settings.accessToken) {
      return null;
    }
    if (Date.now() >= this.plugin.settings.tokenExpiry - 3e5) {
      const refreshed = await this.refreshAccessToken();
      if (!refreshed) {
        return null;
      }
    }
    return this.plugin.settings.accessToken;
  }
  async startAuthFlow() {
    if (!this.credentials) {
      new import_obsidian.Notice("Please configure your Google OAuth credentials first");
      return false;
    }
    return new Promise((resolve) => {
      const http = require("http");
      const url = require("url");
      if (this.localServer) {
        this.localServer.close();
      }
      this.localServer = http.createServer(async (req, res) => {
        const parsedUrl = url.parse(req.url, true);
        if (parsedUrl.pathname === "/callback") {
          const code = parsedUrl.query.code;
          const error = parsedUrl.query.error;
          if (error) {
            res.writeHead(200, { "Content-Type": "text/html" });
            res.end(`
							<html>
								<body style="font-family: sans-serif; text-align: center; padding-top: 50px;">
									<h2>Authentication Failed</h2>
									<p>Error: ${error}</p>
									<p>You can close this window.</p>
								</body>
							</html>
						`);
            this.localServer.close();
            resolve(false);
            return;
          }
          if (code) {
            try {
              await this.exchangeCodeForTokens(code);
              res.writeHead(200, { "Content-Type": "text/html" });
              res.end(`
								<html>
									<body style="font-family: sans-serif; text-align: center; padding-top: 50px;">
										<h2>Authentication Successful!</h2>
										<p>You can close this window and return to Obsidian.</p>
									</body>
								</html>
							`);
              this.localServer.close();
              resolve(true);
            } catch (err) {
              res.writeHead(200, { "Content-Type": "text/html" });
              res.end(`
								<html>
									<body style="font-family: sans-serif; text-align: center; padding-top: 50px;">
										<h2>Authentication Failed</h2>
										<p>Error exchanging code for tokens.</p>
										<p>You can close this window.</p>
									</body>
								</html>
							`);
              this.localServer.close();
              resolve(false);
            }
          }
        }
      });
      this.localServer.listen(42813, () => {
        const authUrl = this.buildAuthUrl();
        require("electron").shell.openExternal(authUrl);
        new import_obsidian.Notice("Opening Google sign-in page in your browser...");
      });
      this.localServer.on("error", (err) => {
        console.error("Auth server error:", err);
        new import_obsidian.Notice("Failed to start authentication server. Port 42813 may be in use.");
        resolve(false);
      });
      setTimeout(() => {
        if (this.localServer) {
          this.localServer.close();
          resolve(false);
        }
      }, 3e5);
    });
  }
  buildAuthUrl() {
    const params = new URLSearchParams({
      client_id: this.credentials.clientId,
      redirect_uri: this.redirectUri,
      response_type: "code",
      scope: SCOPES.join(" "),
      access_type: "offline",
      prompt: "consent"
    });
    return `${GOOGLE_AUTH_URL}?${params.toString()}`;
  }
  async exchangeCodeForTokens(code) {
    const response = await (0, import_obsidian.requestUrl)({
      url: GOOGLE_TOKEN_URL,
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: new URLSearchParams({
        client_id: this.credentials.clientId,
        client_secret: this.credentials.clientSecret,
        code,
        grant_type: "authorization_code",
        redirect_uri: this.redirectUri
      }).toString()
    });
    if (response.status !== 200) {
      throw new Error("Failed to exchange code for tokens");
    }
    const data = response.json;
    this.plugin.settings.accessToken = data.access_token;
    this.plugin.settings.refreshToken = data.refresh_token || this.plugin.settings.refreshToken;
    this.plugin.settings.tokenExpiry = Date.now() + data.expires_in * 1e3;
    await this.plugin.saveSettings();
    new import_obsidian.Notice("Successfully connected to Google Drive!");
  }
  async refreshAccessToken() {
    if (!this.credentials || !this.plugin.settings.refreshToken) {
      return false;
    }
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: GOOGLE_TOKEN_URL,
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          client_id: this.credentials.clientId,
          client_secret: this.credentials.clientSecret,
          refresh_token: this.plugin.settings.refreshToken,
          grant_type: "refresh_token"
        }).toString()
      });
      if (response.status !== 200) {
        return false;
      }
      const data = response.json;
      this.plugin.settings.accessToken = data.access_token;
      this.plugin.settings.tokenExpiry = Date.now() + data.expires_in * 1e3;
      await this.plugin.saveSettings();
      return true;
    } catch (error) {
      console.error("Failed to refresh access token:", error);
      return false;
    }
  }
  async revokeAccess() {
    if (this.plugin.settings.accessToken) {
      try {
        await (0, import_obsidian.requestUrl)({
          url: `https://oauth2.googleapis.com/revoke?token=${this.plugin.settings.accessToken}`,
          method: "POST"
        });
      } catch (error) {
      }
    }
    this.plugin.settings.accessToken = "";
    this.plugin.settings.refreshToken = "";
    this.plugin.settings.tokenExpiry = 0;
    this.plugin.settings.syncFolderId = "";
    await this.plugin.saveSettings();
    new import_obsidian.Notice("Disconnected from Google Drive");
  }
};

// src/googleDrive.ts
var import_obsidian2 = require("obsidian");
var DRIVE_API_BASE = "https://www.googleapis.com/drive/v3";
var DRIVE_UPLOAD_BASE = "https://www.googleapis.com/upload/drive/v3";
var GoogleDriveService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async getAccessToken() {
    const token = await this.plugin.authService.getValidAccessToken();
    if (!token) {
      throw new Error("Not authenticated with Google Drive");
    }
    return token;
  }
  async makeRequest(url, method = "GET", body, headers, contentType) {
    const token = await this.getAccessToken();
    const requestHeaders = {
      "Authorization": `Bearer ${token}`,
      ...headers
    };
    if (contentType) {
      requestHeaders["Content-Type"] = contentType;
    }
    const response = await (0, import_obsidian2.requestUrl)({
      url,
      method,
      headers: requestHeaders,
      body,
      throw: false
    });
    if (response.status >= 400) {
      console.error("Drive API error:", response.status, response.text);
      throw new Error(`Drive API error: ${response.status}`);
    }
    return response;
  }
  async createFolder(name, parentId) {
    const metadata = {
      name,
      mimeType: "application/vnd.google-apps.folder"
    };
    if (parentId) {
      metadata.parents = [parentId];
    }
    const response = await this.makeRequest(
      `${DRIVE_API_BASE}/files`,
      "POST",
      JSON.stringify(metadata),
      {},
      "application/json"
    );
    return response.json;
  }
  async getOrCreateSyncFolder(folderName) {
    const query = `name='${folderName}' and mimeType='application/vnd.google-apps.folder' and trashed=false`;
    const response = await this.makeRequest(
      `${DRIVE_API_BASE}/files?q=${encodeURIComponent(query)}&fields=files(id,name)`
    );
    const files = response.json.files;
    if (files && files.length > 0) {
      return files[0].id;
    }
    const folder = await this.createFolder(folderName);
    return folder.id;
  }
  async listFiles(folderId, pageToken) {
    const query = `'${folderId}' in parents and trashed=false`;
    let url = `${DRIVE_API_BASE}/files?q=${encodeURIComponent(query)}&fields=nextPageToken,files(id,name,mimeType,modifiedTime,size,md5Checksum,parents)&pageSize=1000`;
    if (pageToken) {
      url += `&pageToken=${pageToken}`;
    }
    const response = await this.makeRequest(url);
    return response.json;
  }
  async listAllFiles(folderId) {
    const allFiles = [];
    let pageToken;
    do {
      const result = await this.listFiles(folderId, pageToken);
      allFiles.push(...result.files);
      pageToken = result.nextPageToken;
    } while (pageToken);
    return allFiles;
  }
  async getFileMetadata(fileId) {
    const response = await this.makeRequest(
      `${DRIVE_API_BASE}/files/${fileId}?fields=id,name,mimeType,modifiedTime,size,md5Checksum,parents`
    );
    return response.json;
  }
  async downloadFile(fileId) {
    const response = await this.makeRequest(
      `${DRIVE_API_BASE}/files/${fileId}?alt=media`
    );
    return response.arrayBuffer;
  }
  async uploadFile(name, content, mimeType, parentId, existingFileId) {
    const metadata = {
      name
    };
    if (!existingFileId) {
      metadata.parents = [parentId];
    }
    const boundary = "-------gsync_boundary";
    const delimiter = `\r
--${boundary}\r
`;
    const closeDelimiter = `\r
--${boundary}--`;
    const metadataStr = JSON.stringify(metadata);
    const encoder = new TextEncoder();
    const metadataBytes = encoder.encode(
      delimiter + "Content-Type: application/json; charset=UTF-8\r\n\r\n" + metadataStr + delimiter + `Content-Type: ${mimeType}\r
Content-Transfer-Encoding: base64\r
\r
`
    );
    const closeBytes = encoder.encode(closeDelimiter);
    const base64Content = this.arrayBufferToBase64(content);
    const contentBytes = encoder.encode(base64Content);
    const body = new Uint8Array(metadataBytes.length + contentBytes.length + closeBytes.length);
    body.set(metadataBytes, 0);
    body.set(contentBytes, metadataBytes.length);
    body.set(closeBytes, metadataBytes.length + contentBytes.length);
    const url = existingFileId ? `${DRIVE_UPLOAD_BASE}/files/${existingFileId}?uploadType=multipart&fields=id,name,mimeType,modifiedTime,size,md5Checksum` : `${DRIVE_UPLOAD_BASE}/files?uploadType=multipart&fields=id,name,mimeType,modifiedTime,size,md5Checksum`;
    const method = existingFileId ? "PATCH" : "POST";
    const response = await this.makeRequest(
      url,
      method,
      body.buffer,
      {},
      `multipart/related; boundary=${boundary}`
    );
    return response.json;
  }
  async deleteFile(fileId) {
    await this.makeRequest(
      `${DRIVE_API_BASE}/files/${fileId}`,
      "DELETE"
    );
  }
  async moveToTrash(fileId) {
    await this.makeRequest(
      `${DRIVE_API_BASE}/files/${fileId}`,
      "PATCH",
      JSON.stringify({ trashed: true }),
      {},
      "application/json"
    );
  }
  arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = "";
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
  async buildRemoteFileIndex(folderId, basePath = "") {
    const index = /* @__PURE__ */ new Map();
    const files = await this.listAllFiles(folderId);
    for (const file of files) {
      const path = basePath ? `${basePath}/${file.name}` : file.name;
      const isFolder = file.mimeType === "application/vnd.google-apps.folder";
      index.set(path, {
        path,
        name: file.name,
        mtime: new Date(file.modifiedTime).getTime(),
        size: parseInt(file.size || "0"),
        isFolder,
        driveId: file.id,
        driveMtime: new Date(file.modifiedTime).getTime(),
        md5Checksum: file.md5Checksum
      });
      if (isFolder) {
        const subIndex = await this.buildRemoteFileIndex(file.id, path);
        subIndex.forEach((value, key) => index.set(key, value));
      }
    }
    return index;
  }
  async ensureFolderPath(folderPath, rootFolderId) {
    const parts = folderPath.split("/").filter((p) => p);
    let currentParentId = rootFolderId;
    for (const part of parts) {
      const query = `name='${part}' and '${currentParentId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`;
      const response = await this.makeRequest(
        `${DRIVE_API_BASE}/files?q=${encodeURIComponent(query)}&fields=files(id,name)`
      );
      const files = response.json.files;
      if (files && files.length > 0) {
        currentParentId = files[0].id;
      } else {
        const folder = await this.createFolder(part, currentParentId);
        currentParentId = folder.id;
      }
    }
    return currentParentId;
  }
  async getFileIdByPath(filePath, rootFolderId) {
    const parts = filePath.split("/").filter((p) => p);
    let currentParentId = rootFolderId;
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      const isLast = i === parts.length - 1;
      const mimeTypeCondition = isLast ? "" : ` and mimeType='application/vnd.google-apps.folder'`;
      const query = `name='${part}' and '${currentParentId}' in parents${mimeTypeCondition} and trashed=false`;
      const response = await this.makeRequest(
        `${DRIVE_API_BASE}/files?q=${encodeURIComponent(query)}&fields=files(id,name)`
      );
      const files = response.json.files;
      if (!files || files.length === 0) {
        return null;
      }
      currentParentId = files[0].id;
    }
    return currentParentId;
  }
};

// src/syncService.ts
var import_obsidian3 = require("obsidian");
var SyncService = class {
  constructor(plugin) {
    this.isSyncing = false;
    this.plugin = plugin;
  }
  onSyncStatusChange(callback) {
    this.syncStatusCallback = callback;
  }
  updateStatus(status) {
    if (this.syncStatusCallback) {
      this.syncStatusCallback(status);
    }
  }
  async sync() {
    if (this.isSyncing) {
      new import_obsidian3.Notice("Sync already in progress");
      return;
    }
    if (!this.plugin.authService.isAuthenticated()) {
      new import_obsidian3.Notice("Please authenticate with Google Drive first");
      return;
    }
    this.isSyncing = true;
    this.updateStatus({ status: "syncing", message: "Starting sync..." });
    try {
      if (!this.plugin.settings.syncFolderId) {
        this.updateStatus({ status: "syncing", message: "Creating sync folder..." });
        const folderId = await this.plugin.driveService.getOrCreateSyncFolder(
          this.plugin.settings.syncFolderName
        );
        this.plugin.settings.syncFolderId = folderId;
        await this.plugin.saveSettings();
      }
      this.updateStatus({ status: "syncing", message: "Scanning local files..." });
      const localIndex = await this.buildLocalFileIndex();
      this.updateStatus({ status: "syncing", message: "Scanning remote files..." });
      const remoteIndex = await this.plugin.driveService.buildRemoteFileIndex(
        this.plugin.settings.syncFolderId
      );
      this.updateStatus({ status: "syncing", message: "Planning sync..." });
      const plan = this.createSyncPlan(localIndex, remoteIndex);
      await this.executeSyncPlan(plan, localIndex, remoteIndex);
      this.plugin.settings.lastSyncTime = Date.now();
      await this.plugin.saveSettings();
      this.updateStatus({ status: "idle", message: "Sync completed" });
      new import_obsidian3.Notice("Sync completed successfully");
    } catch (error) {
      console.error("Sync error:", error);
      this.updateStatus({ status: "error", message: `Sync failed: ${error}` });
      new import_obsidian3.Notice(`Sync failed: ${error}`);
    } finally {
      this.isSyncing = false;
    }
  }
  async buildLocalFileIndex() {
    const index = /* @__PURE__ */ new Map();
    const vault = this.plugin.app.vault;
    const processFile = async (file) => {
      if (this.shouldExclude(file.path)) {
        return;
      }
      const stat = await vault.adapter.stat(file.path);
      if (stat) {
        index.set(file.path, {
          path: file.path,
          name: file.name,
          mtime: stat.mtime,
          size: stat.size,
          isFolder: false
        });
      }
    };
    const processFolder = (folder) => {
      if (this.shouldExclude(folder.path)) {
        return;
      }
      if (folder.path !== "/") {
        index.set(folder.path, {
          path: folder.path,
          name: folder.name,
          mtime: 0,
          size: 0,
          isFolder: true
        });
      }
    };
    const allFiles = vault.getFiles();
    for (const file of allFiles) {
      await processFile(file);
    }
    const root = vault.getRoot();
    const processAllFolders = (folder) => {
      processFolder(folder);
      for (const child of folder.children) {
        if (child instanceof import_obsidian3.TFolder) {
          processAllFolders(child);
        }
      }
    };
    processAllFolders(root);
    return index;
  }
  shouldExclude(path) {
    for (const folder of this.plugin.settings.excludedFolders) {
      if (path.startsWith(folder) || path.startsWith("/" + folder)) {
        return true;
      }
    }
    for (const ext of this.plugin.settings.excludedExtensions) {
      if (path.endsWith(ext)) {
        return true;
      }
    }
    if (!this.plugin.settings.includeHiddenFiles) {
      const parts = path.split("/");
      for (const part of parts) {
        if (part.startsWith(".") && part !== ".") {
          return true;
        }
      }
    }
    return false;
  }
  createSyncPlan(localIndex, remoteIndex) {
    const plan = {
      uploads: [],
      downloads: [],
      deleteLocal: [],
      deleteRemote: [],
      conflicts: []
    };
    const lastSyncTime = this.plugin.settings.lastSyncTime;
    for (const [path, localFile] of localIndex) {
      const remoteFile = remoteIndex.get(path);
      if (!remoteFile) {
        if (lastSyncTime === 0 || localFile.mtime > lastSyncTime) {
          plan.uploads.push(localFile);
        } else {
          plan.deleteLocal.push(localFile);
        }
      } else if (!localFile.isFolder && !remoteFile.isFolder) {
        const localNewer = localFile.mtime > (remoteFile.driveMtime || 0);
        const remoteNewer = (remoteFile.driveMtime || 0) > localFile.mtime;
        if (localNewer && remoteNewer) {
          plan.conflicts.push({ localFile, remoteFile, path });
        } else if (localNewer && localFile.mtime > lastSyncTime) {
          plan.uploads.push({ ...localFile, driveId: remoteFile.driveId });
        } else if (remoteNewer && (remoteFile.driveMtime || 0) > lastSyncTime) {
          plan.downloads.push(remoteFile);
        }
      }
    }
    for (const [path, remoteFile] of remoteIndex) {
      if (!localIndex.has(path)) {
        if (lastSyncTime === 0 || (remoteFile.driveMtime || 0) > lastSyncTime) {
          plan.downloads.push(remoteFile);
        } else {
          plan.deleteRemote.push(remoteFile);
        }
      }
    }
    return plan;
  }
  async executeSyncPlan(plan, localIndex, remoteIndex) {
    const total = plan.uploads.length + plan.downloads.length + plan.deleteLocal.length + plan.deleteRemote.length + plan.conflicts.length;
    let progress = 0;
    for (const conflict of plan.conflicts) {
      progress++;
      this.updateStatus({
        status: "syncing",
        message: `Resolving conflict: ${conflict.path}`,
        progress,
        total
      });
      await this.resolveConflict(conflict);
    }
    for (const file of plan.uploads) {
      if (file.isFolder)
        continue;
      progress++;
      this.updateStatus({
        status: "syncing",
        message: `Uploading: ${file.path}`,
        progress,
        total
      });
      await this.uploadFile(file);
    }
    for (const file of plan.downloads) {
      if (file.isFolder)
        continue;
      progress++;
      this.updateStatus({
        status: "syncing",
        message: `Downloading: ${file.path}`,
        progress,
        total
      });
      await this.downloadFile(file);
    }
    for (const file of plan.deleteLocal) {
      progress++;
      this.updateStatus({
        status: "syncing",
        message: `Deleting local: ${file.path}`,
        progress,
        total
      });
      await this.deleteLocalFile(file);
    }
    for (const file of plan.deleteRemote) {
      progress++;
      this.updateStatus({
        status: "syncing",
        message: `Deleting remote: ${file.path}`,
        progress,
        total
      });
      await this.deleteRemoteFile(file);
    }
  }
  async resolveConflict(conflict) {
    const resolution = this.plugin.settings.conflictResolution;
    switch (resolution) {
      case "local":
        await this.uploadFile(conflict.localFile);
        break;
      case "remote":
        await this.downloadFile(conflict.remoteFile);
        break;
      case "newer":
        if (conflict.localFile.mtime > (conflict.remoteFile.driveMtime || 0)) {
          await this.uploadFile(conflict.localFile);
        } else {
          await this.downloadFile(conflict.remoteFile);
        }
        break;
      case "ask":
        const parts = conflict.path.split(".");
        const ext = parts.length > 1 ? "." + parts.pop() : "";
        const base = parts.join(".");
        const newPath = `${base}_conflict_${Date.now()}${ext}`;
        const content = await this.plugin.app.vault.adapter.read(conflict.path);
        await this.plugin.app.vault.create(newPath, content);
        await this.downloadFile(conflict.remoteFile);
        break;
    }
  }
  async uploadFile(file) {
    try {
      const content = await this.plugin.app.vault.adapter.readBinary(file.path);
      const mimeType = this.getMimeType(file.path);
      const parentPath = file.path.substring(0, file.path.lastIndexOf("/"));
      let parentId = this.plugin.settings.syncFolderId;
      if (parentPath) {
        parentId = await this.plugin.driveService.ensureFolderPath(
          parentPath,
          this.plugin.settings.syncFolderId
        );
      }
      await this.plugin.driveService.uploadFile(
        file.name,
        content,
        mimeType,
        parentId,
        file.driveId
      );
      if (this.plugin.settings.debugMode) {
        console.log(`Uploaded: ${file.path}`);
      }
    } catch (error) {
      console.error(`Failed to upload ${file.path}:`, error);
      throw error;
    }
  }
  async downloadFile(file) {
    if (!file.driveId) {
      console.error(`No drive ID for file: ${file.path}`);
      return;
    }
    try {
      const content = await this.plugin.driveService.downloadFile(file.driveId);
      const parentPath = file.path.substring(0, file.path.lastIndexOf("/"));
      if (parentPath) {
        const exists = await this.plugin.app.vault.adapter.exists(parentPath);
        if (!exists) {
          await this.plugin.app.vault.createFolder(parentPath);
        }
      }
      await this.plugin.app.vault.adapter.writeBinary(file.path, content);
      if (this.plugin.settings.debugMode) {
        console.log(`Downloaded: ${file.path}`);
      }
    } catch (error) {
      console.error(`Failed to download ${file.path}:`, error);
      throw error;
    }
  }
  async deleteLocalFile(file) {
    try {
      if (file.isFolder) {
        const exists = await this.plugin.app.vault.adapter.exists(file.path);
        if (exists) {
          const list = await this.plugin.app.vault.adapter.list(file.path);
          if (list.files.length === 0 && list.folders.length === 0) {
            await this.plugin.app.vault.adapter.rmdir(file.path, false);
          }
        }
      } else {
        const exists = await this.plugin.app.vault.adapter.exists(file.path);
        if (exists) {
          const abstractFile = this.plugin.app.vault.getAbstractFileByPath(file.path);
          if (abstractFile instanceof import_obsidian3.TFile) {
            await this.plugin.app.vault.trash(abstractFile, true);
          }
        }
      }
      if (this.plugin.settings.debugMode) {
        console.log(`Deleted local: ${file.path}`);
      }
    } catch (error) {
      console.error(`Failed to delete local ${file.path}:`, error);
    }
  }
  async deleteRemoteFile(file) {
    if (!file.driveId)
      return;
    try {
      await this.plugin.driveService.moveToTrash(file.driveId);
      if (this.plugin.settings.debugMode) {
        console.log(`Deleted remote: ${file.path}`);
      }
    } catch (error) {
      console.error(`Failed to delete remote ${file.path}:`, error);
    }
  }
  getMimeType(path) {
    var _a;
    const ext = (_a = path.split(".").pop()) == null ? void 0 : _a.toLowerCase();
    const mimeTypes = {
      "md": "text/markdown",
      "txt": "text/plain",
      "json": "application/json",
      "css": "text/css",
      "js": "application/javascript",
      "png": "image/png",
      "jpg": "image/jpeg",
      "jpeg": "image/jpeg",
      "gif": "image/gif",
      "svg": "image/svg+xml",
      "pdf": "application/pdf",
      "mp3": "audio/mpeg",
      "mp4": "video/mp4",
      "webp": "image/webp",
      "canvas": "application/json"
    };
    return mimeTypes[ext || ""] || "application/octet-stream";
  }
  isSyncInProgress() {
    return this.isSyncing;
  }
};

// src/settingsTab.ts
var import_obsidian4 = require("obsidian");
var GSyncSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Google Drive Sync Settings" });
    containerEl.createEl("h3", { text: "Google OAuth Credentials" });
    containerEl.createEl("p", {
      text: "To use this plugin, you need to create your own Google OAuth credentials.",
      cls: "setting-item-description"
    });
    const instructionsEl = containerEl.createEl("details");
    instructionsEl.createEl("summary", { text: "How to get OAuth credentials" });
    const instructionsList = instructionsEl.createEl("ol");
    instructionsList.createEl("li", { text: "Go to the Google Cloud Console (https://console.cloud.google.com/)" });
    instructionsList.createEl("li", { text: "Create a new project or select an existing one" });
    instructionsList.createEl("li", { text: "Enable the Google Drive API for your project" });
    instructionsList.createEl("li", { text: 'Go to "Credentials" and create OAuth 2.0 credentials' });
    instructionsList.createEl("li", { text: 'Set the application type to "Desktop app"' });
    instructionsList.createEl("li", { text: "Add http://localhost:42813/callback as an authorized redirect URI" });
    instructionsList.createEl("li", { text: "Copy the Client ID and Client Secret below" });
    let clientIdInput;
    let clientSecretInput;
    new import_obsidian4.Setting(containerEl).setName("Client ID").setDesc("Your Google OAuth Client ID").addText((text) => {
      clientIdInput = text;
      text.setPlaceholder("Enter your Client ID").inputEl.type = "password";
    });
    new import_obsidian4.Setting(containerEl).setName("Client Secret").setDesc("Your Google OAuth Client Secret").addText((text) => {
      clientSecretInput = text;
      text.setPlaceholder("Enter your Client Secret").inputEl.type = "password";
    });
    new import_obsidian4.Setting(containerEl).setName("Save Credentials & Connect").setDesc("Save your credentials and authenticate with Google Drive").addButton((button) => button.setButtonText("Connect to Google Drive").setCta().onClick(async () => {
      const clientId = clientIdInput.getValue().trim();
      const clientSecret = clientSecretInput.getValue().trim();
      if (!clientId || !clientSecret) {
        new import_obsidian4.Notice("Please enter both Client ID and Client Secret");
        return;
      }
      this.plugin.authService.setCredentials({ clientId, clientSecret });
      const success = await this.plugin.authService.startAuthFlow();
      if (success) {
        this.display();
      }
    }));
    containerEl.createEl("h3", { text: "Connection Status" });
    const isAuthenticated = this.plugin.authService.isAuthenticated();
    const statusSetting = new import_obsidian4.Setting(containerEl).setName("Status").setDesc(isAuthenticated ? "Connected to Google Drive" : "Not connected");
    if (isAuthenticated) {
      statusSetting.addButton((button) => button.setButtonText("Disconnect").setWarning().onClick(async () => {
        await this.plugin.authService.revokeAccess();
        this.display();
      }));
    }
    containerEl.createEl("h3", { text: "Sync Configuration" });
    new import_obsidian4.Setting(containerEl).setName("Sync Folder Name").setDesc("Name of the folder in Google Drive where your vault will be synced").addText((text) => text.setPlaceholder("ObsidianVault").setValue(this.plugin.settings.syncFolderName).onChange(async (value) => {
      this.plugin.settings.syncFolderName = value || "ObsidianVault";
      this.plugin.settings.syncFolderId = "";
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Auto Sync").setDesc("Automatically sync your vault at regular intervals").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
      this.plugin.settings.autoSync = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.startAutoSync();
      } else {
        this.plugin.stopAutoSync();
      }
    }));
    new import_obsidian4.Setting(containerEl).setName("Auto Sync Interval").setDesc("How often to sync (in minutes)").addSlider((slider) => slider.setLimits(5, 120, 5).setValue(this.plugin.settings.autoSyncInterval).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.autoSyncInterval = value;
      await this.plugin.saveSettings();
      if (this.plugin.settings.autoSync) {
        this.plugin.stopAutoSync();
        this.plugin.startAutoSync();
      }
    }));
    new import_obsidian4.Setting(containerEl).setName("Sync on Startup").setDesc("Automatically sync when Obsidian starts").addToggle((toggle) => toggle.setValue(this.plugin.settings.syncOnStartup).onChange(async (value) => {
      this.plugin.settings.syncOnStartup = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Conflict Resolution" });
    new import_obsidian4.Setting(containerEl).setName("Conflict Resolution Strategy").setDesc("How to handle conflicts when both local and remote files have changed").addDropdown((dropdown) => dropdown.addOption("newer", "Keep newer version").addOption("local", "Always keep local version").addOption("remote", "Always keep remote version").addOption("ask", "Keep both (rename local)").setValue(this.plugin.settings.conflictResolution).onChange(async (value) => {
      this.plugin.settings.conflictResolution = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "File Filters" });
    new import_obsidian4.Setting(containerEl).setName("Excluded Folders").setDesc("Folders to exclude from sync (comma-separated)").addTextArea((text) => text.setPlaceholder(".obsidian, .git, .trash").setValue(this.plugin.settings.excludedFolders.join(", ")).onChange(async (value) => {
      this.plugin.settings.excludedFolders = value.split(",").map((s) => s.trim()).filter((s) => s.length > 0);
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Excluded Extensions").setDesc("File extensions to exclude from sync (comma-separated, include the dot)").addTextArea((text) => text.setPlaceholder(".tmp, .bak").setValue(this.plugin.settings.excludedExtensions.join(", ")).onChange(async (value) => {
      this.plugin.settings.excludedExtensions = value.split(",").map((s) => s.trim()).filter((s) => s.length > 0);
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Include Hidden Files").setDesc("Include files and folders starting with a dot (except .obsidian)").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeHiddenFiles).onChange(async (value) => {
      this.plugin.settings.includeHiddenFiles = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Manual Sync" });
    new import_obsidian4.Setting(containerEl).setName("Sync Now").setDesc("Manually trigger a sync").addButton((button) => button.setButtonText("Sync Now").setCta().onClick(async () => {
      if (!this.plugin.authService.isAuthenticated()) {
        new import_obsidian4.Notice("Please connect to Google Drive first");
        return;
      }
      await this.plugin.syncService.sync();
    }));
    if (this.plugin.settings.lastSyncTime > 0) {
      const lastSync = new Date(this.plugin.settings.lastSyncTime);
      new import_obsidian4.Setting(containerEl).setName("Last Sync").setDesc(lastSync.toLocaleString());
    }
    containerEl.createEl("h3", { text: "Advanced" });
    new import_obsidian4.Setting(containerEl).setName("Debug Mode").setDesc("Enable debug logging in the console").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
      this.plugin.settings.debugMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Reset Sync State").setDesc("Clear the last sync time to force a full sync on next run").addButton((button) => button.setButtonText("Reset").setWarning().onClick(async () => {
      this.plugin.settings.lastSyncTime = 0;
      this.plugin.settings.syncFolderId = "";
      await this.plugin.saveSettings();
      new import_obsidian4.Notice("Sync state reset. Next sync will be a full sync.");
      this.display();
    }));
  }
};

// src/main.ts
var GSyncPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.statusBarItem = null;
    this.ribbonIconEl = null;
    this.autoSyncInterval = null;
  }
  async onload() {
    await this.loadSettings();
    this.authService = new GoogleAuthService(this);
    this.driveService = new GoogleDriveService(this);
    this.syncService = new SyncService(this);
    this.syncService.onSyncStatusChange((status) => {
      this.updateStatusBar(status);
      this.updateRibbonIcon(status);
    });
    this.ribbonIconEl = this.addRibbonIcon(
      "cloud",
      "Google Drive Sync",
      async () => {
        if (this.syncService.isSyncInProgress()) {
          new import_obsidian5.Notice("Sync already in progress");
          return;
        }
        if (!this.authService.isAuthenticated()) {
          new import_obsidian5.Notice("Please configure Google Drive authentication in settings");
          return;
        }
        await this.syncService.sync();
      }
    );
    this.ribbonIconEl.addClass("gsync-ribbon-icon");
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.addClass("gsync-status-bar");
    this.updateStatusBar({ status: "idle", message: "Ready" });
    this.addSettingTab(new GSyncSettingTab(this.app, this));
    this.addCommand({
      id: "gsync-sync-now",
      name: "Sync Now",
      callback: async () => {
        if (!this.authService.isAuthenticated()) {
          new import_obsidian5.Notice("Please configure Google Drive authentication first");
          return;
        }
        await this.syncService.sync();
      }
    });
    this.addCommand({
      id: "gsync-force-upload",
      name: "Force Upload All",
      callback: async () => {
        if (!this.authService.isAuthenticated()) {
          new import_obsidian5.Notice("Please configure Google Drive authentication first");
          return;
        }
        const originalTime = this.settings.lastSyncTime;
        this.settings.lastSyncTime = 0;
        new import_obsidian5.Notice("Starting full upload...");
        await this.syncService.sync();
        if (this.settings.lastSyncTime === 0) {
          this.settings.lastSyncTime = originalTime;
        }
      }
    });
    this.addCommand({
      id: "gsync-force-download",
      name: "Force Download All",
      callback: async () => {
        if (!this.authService.isAuthenticated()) {
          new import_obsidian5.Notice("Please configure Google Drive authentication first");
          return;
        }
        new import_obsidian5.Notice("Force download not implemented yet - use Sync Now");
      }
    });
    this.addCommand({
      id: "gsync-open-settings",
      name: "Open Settings",
      callback: () => {
        const setting = this.app.setting;
        setting.open();
        setting.openTabById("obsidian-gsync");
      }
    });
    if (this.settings.autoSync && this.authService.isAuthenticated()) {
      this.startAutoSync();
    }
    if (this.settings.syncOnStartup && this.authService.isAuthenticated()) {
      setTimeout(() => {
        this.syncService.sync();
      }, 5e3);
    }
    console.log("GSync plugin loaded");
  }
  onunload() {
    this.stopAutoSync();
    console.log("GSync plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  startAutoSync() {
    this.stopAutoSync();
    const intervalMs = this.settings.autoSyncInterval * 60 * 1e3;
    this.autoSyncInterval = window.setInterval(async () => {
      if (!this.syncService.isSyncInProgress() && this.authService.isAuthenticated()) {
        if (this.settings.debugMode) {
          console.log("Auto sync triggered");
        }
        await this.syncService.sync();
      }
    }, intervalMs);
    this.registerInterval(this.autoSyncInterval);
  }
  stopAutoSync() {
    if (this.autoSyncInterval !== null) {
      window.clearInterval(this.autoSyncInterval);
      this.autoSyncInterval = null;
    }
  }
  updateStatusBar(status) {
    if (!this.statusBarItem)
      return;
    let text = "";
    let title = "";
    switch (status.status) {
      case "idle":
        text = "GSync: Ready";
        title = status.message;
        break;
      case "syncing":
        if (status.progress !== void 0 && status.total !== void 0) {
          text = `GSync: ${status.progress}/${status.total}`;
        } else {
          text = "GSync: Syncing...";
        }
        title = status.message;
        break;
      case "error":
        text = "GSync: Error";
        title = status.message;
        break;
      case "authenticated":
        text = "GSync: Connected";
        title = "Connected to Google Drive";
        break;
      case "unauthenticated":
        text = "GSync: Not Connected";
        title = "Click to configure";
        break;
    }
    this.statusBarItem.setText(text);
    this.statusBarItem.setAttr("title", title);
    this.statusBarItem.removeClass("gsync-status-idle");
    this.statusBarItem.removeClass("gsync-status-syncing");
    this.statusBarItem.removeClass("gsync-status-error");
    this.statusBarItem.addClass(`gsync-status-${status.status}`);
  }
  updateRibbonIcon(status) {
    if (!this.ribbonIconEl)
      return;
    this.ribbonIconEl.removeClass("gsync-syncing");
    this.ribbonIconEl.removeClass("gsync-error");
    if (status.status === "syncing") {
      this.ribbonIconEl.addClass("gsync-syncing");
    } else if (status.status === "error") {
      this.ribbonIconEl.addClass("gsync-error");
    }
  }
};
